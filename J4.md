## J4 WORKSHEET 

#### Question 1.
Explain why the class declaration is not possible in Java

**Because in Java you cannot inherit from multiple classes because Java uses a single inheritance model,**
**therefore, we can only have Lion extends Mammal or Lion extends Carnivore.**
**To accomplish inheritance we can do**

`public class Lion extends Mammal implements Carnivore {`

`}`

### Question 2. 
What are some of the functional differences between an abstract class and an interface?
**The abstract and interface keywords provide the user with the methods that their classs must declare**

**Abstract classes unlike interfaces provides methods, constructors and variables that a child class can**
**use inhereted from its parent class.**

### Question 3.
Using those methods in LinkedList complete the realization of a Stack and Queue:

`public void push(int v){`

   ``addToFront(v);``

``}``

`public int pop(){`

   `` rmFromFront(v);``
``}``

``public void enqueue(int v){``

   ``addToBack(v);``

``}``

``public int dequeue(){``

   ``rmFromFront(v);``

``}``

``public int peek(){``

  ``int v = rmFromFront(v);``

  ``addToFront(v);``

  ``return v;``

``}``

### Question 4.
Rewrite the Stack and Queue interfaces from above to be generic, as well as the LinkedList.
Explain how this is now generic to manage collections of any class.

``public interface Stack< T > {``

   ``public void push(T v);``

   ``public T pop();``

   ``public T peek();``

``}``

``public interface Queue< T > {``

   ``public void enqueue(T v);``

   ``public T dequeue();``

   ``public T peek();``

``}``

``public class LinkedList< T > implements Stack< T>, Queue< T> {``

  ``public LinkedList() {/*...*/}``  

  ``public void addToFront(T v) {/*...*/}``

  ``public T rmFromFront() {/*...*/}``

  ``public void addToBack(T v) {/*...*/}``  

  ``public void rmFromBack() {/*...*/}``

``public void push(T v) {``

 ``addToFront(v);``

  ``}``

``public T pop() { ``

  ``rmFromFront(v);``

 ``}``

``public void enqueue(T v) {``

  ``addToBack(v);``

``}``

``public T dequeue() {``

 ``rmFromFront(v);``

  ``}``

  ``public T peek() {``

  ``T v = rmFromFront(v);``

  ``addToFront(v);``

 ``return v;``

  ``}``

``}``


### Question 5.
The code below does not use Java generics. Update it to do so. Notably, there should not need 
casting, but no, the solution isn’t just removing the (String) casting before the .get method.

``public class TestHashMap {``

 `` public static void main(String[] argv) {``

   ``HashMap< String, String> fabFour = new HashMap< String, String>();``
    ``fabFour.put("John", "John Lennon");``

   ``fabFour.put("Paul", "Paul McCartney");``

   ``fabFour.put("George", "George Harrison");``

   ``fabFour.put("Ringo", "Ringo Star");``

   ``String fullName = fabFour.get("Ring");``

   ``System.ou.println(fullName);``

### Question 6.
What is “Erasure” with java generics?

**The Java runtime does not recognize generics; during compilation, all “generic”**
**types are replaced with their specific types. When a generic is used, the compiler**
**changes the Shelf class to use only the String type, substituting T with String.**
**As a result, any operation that should return type T uses a cast to that type.**

What does the code “erase” to?

``public static void main(final String args[]) {``

   ``Shelf favorite_words = shelfBuilder();``

   ``favorite_words.addItem((String)"Zoetrope");``

   ``favorite_words.addItem((String)"Succinct");``
        
   ``String s = (String)favorite_words.getItem(1);``

   ``System.out.println(s);``
   
``}``


### Question 7.
Expected output:

### Question 8.
Consider the following code snippets for a LinkedList you may implement and a main method:
Explain why the line with MARK is extremely inefficient? Use Big-O to explain.

### Question 9.
Continuing with the example above, explain why expanding LinkedList to implement Iterable solves 
the inefficiency problem you described above.

### Question 10.
Explain why the Comparable interface is an interface rather than class?

### Question 11.
Add the compareTo method in the Car class above. So that the main method will print out:





